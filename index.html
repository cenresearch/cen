<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AUS Research Clusters</title>

  <link href="https://unpkg.com/tabulator-tables@5.6.0/dist/css/tabulator.min.css" rel="stylesheet">
  <script src="https://unpkg.com/tabulator-tables@5.6.0/dist/js/tabulator.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root { --bg:#fff; --fg:#111; --muted:#6b7280; --border:#e5e7eb; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--fg); }
    .topnav { position: sticky; top: 0; background: #fff; border-bottom: 1px solid var(--border); display: flex; gap: 16px; padding: 10px 16px; z-index: 2000; }
    .topnav a { text-decoration: none; color: #111; font-size: 14px; font-weight: 500; }
    .topnav a:hover { color: #007acc; }
    .topnav a.active { background-color: #111; color: white; font-weight: bold; padding: 4px 10px; border-radius: 8px; }

    .controls { padding: 14px; background: #f9fafb; border-bottom: 1px solid var(--border); }
    .controls label { margin-right: 20px; font-size: 14px; }
    .controls select, .controls input { margin-left: 8px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; font-size: 16px; }

    .popup-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
    .popup-content {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 8px;
      padding: 15px;
      width: 92%;
      max-width: 92%;
      max-height: 92%;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 1001;
      font-size: 11px;
    }
    .popup-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 8px; }
    .popup-title { font-size: 14px; font-weight: bold; color: #333; }
    .popup-close { background: none; border: none; font-size: 20px; cursor: pointer; color: #666; }
    .popup-close:hover { color: #000; }

    .publication-item { margin-bottom: 8px; padding: 6px; border-left: 3px solid #007acc; background: #f9f9f9; }
    .publication-year { font-weight: bold; color: #007acc; margin-bottom: 4px; font-size: 12px; }
    .publication-title { font-size: 12px; line-height: 1.3; margin-bottom: 3px; }
    .publication-meta { font-size: 9px; color: #666; }
    .cluster-theme-info { font-size: 9px; color: #007acc; margin-top: 2px; font-weight: bold; }

    .pub-count { color: #dc2626; font-weight: bold; text-decoration: underline; cursor: pointer; font-size: 10px; margin-left: 8px; }
    .pub-count:hover { color: #b91c1c; text-decoration: none; }
    .dyn-pubs { fill: #334155; font-weight: 600; }
    .dyn-auths { fill: #1d4ed8; font-weight: 600; }

    /* bigger counts next to names */
    .pub-count { font-size: 20px !important; }
    .dyn-pubs { font-size: 20px !important; }
    .dyn-auths { font-size: 20px !important; }

    /* compact matrix */
    table.matrix { table-layout: fixed; border-collapse: collapse; font-size: 11px; width: 100%; }
    table.matrix th, table.matrix td { border:1px solid #e5e7eb; padding:2px 3px; }
    table.matrix td { width: 28px; min-width: 28px; max-width: 28px; height: 22px; line-height: 1.0; text-align: center; }
    table.matrix th { background:#f9fafb; text-align:left; position:sticky; top:0; white-space:nowrap; font-size: 11px; } /* smaller names */
    table.matrix td.self { font-weight:700; }
    table.matrix td.zero { color:#6b7280; }
	table.matrix thead th {
	  white-space: normal;   /* allow wrapping */
	  line-height: 1.1;      /* tighter lines */
	  text-align: center;    /* optional */
	}
    .matrix-caption { margin:6px 0 10px 0; color:#334155; font-size:12px; }

    svg { width: 100%; height: auto; display:block; }
	
	/* sticky close button inside popup body */
	.sticky-close {
	  position: sticky;
	  top: 0;
	  display: flex;
	  justify-content: flex-end;
	  background: #fff;
	  padding: 6px 0;
	  z-index: 3;
	  border-bottom: 1px solid #eee;
	}
	.sticky-close button {
	  background: #0f172a;
	  color: #fff;
	  border: 0;
	  border-radius: 8px;
	  padding: 4px 10px;
	  font-size: 12px;
	  cursor: pointer;
	}
	.sticky-close button:hover { background: #000; }

  </style>
</head>
<body>
  <div class="topnav">
    <a href="./">Home</a>
    <a href="clusters.html">Clusters</a>
    <a href="radial.html">Radial Clusters</a>
    <a href="themes.html">Themes</a>
    <a href="classification.html">Classification</a>
    <a href="authors.html">Authors</a>
    <a href="authors_clusters.html">Authors-Clusters</a>
    <a href="cen_collab.html">Collaborations</a>
    <a href="metrics.html">Metrics</a>
    <a href="process.html">Process Diagram</a>
  </div>

  <h1>Clusters - Publications: 1/1/2022 - 15/8/2025 <span style="color:#e11d48; font-size:12px;">click on author names for details</span></h1>
  

  
 <div style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px; padding: 12px; margin: 16px; font-size: 16px;">
    <div style="color: #dc2626; margin-bottom: 8px;">
      <strong>Red (N)</strong> = total unique publications in data.
    </div>
    <div style="color: #000000; margin-bottom: 8px;">
      <strong>Gray [P:x]</strong> = unique publications for visible authors after Min Papers filter.
    </div>
    <div style="color: #0000FF; margin-bottom: 8px;">
      <strong>Blue {A:y}</strong> = count of unique visible authors.
    </div>
	<div style="color: #0ea5e9;">
      <strong>[matrix] </strong> = pairwise shared counts.
    </div>
</div>

  <script>
    (function () {
      const current = (location.pathname.split('/').pop() || 'index.html').split('?')[0];
      document.querySelectorAll('.topnav a').forEach(a => {
        const href = (a.getAttribute('href') || '').split('?')[0];
        const target = (href.split('/').pop() || 'index.html');
        if (target === current || (href === './' && (current === '' || current === 'index.html'))) a.classList.add('active');
      });
    })();
  </script>

  <div class="controls">
    <label>
      Layout
      <select id="layoutSelect">
        <option value="tree">Tree (Left-to-Right)</option>
        <option value="cluster">Cluster</option>
      </select>
    </label>
    <label>
      Min Papers
      <input type="number" id="minPapers" value="1" min="1" max="50">
    </label>
    <button onclick="updateVisualization()">Update</button>
  </div>

  <div class="popup-overlay" id="popupOverlay">
    <div class="popup-content">
      <div class="popup-header">
        <div class="popup-title" id="popupTitle">Author Publications</div>
        <button class="popup-close" onclick="closePopup()">&times;</button>
      </div>
      <div id="popupBody"></div>
    </div>
  </div>

  <div id="mount"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    let rawData = null;
    let currentLayout = 'tree';
    let minPapers = 1;
    const LINK_PAD = 30;
    const LINK_GAP = 14;

    function showAuthorPublications(authorData) {
      const popupTitle = document.getElementById('popupTitle');
      const popupBody = document.getElementById('popupBody');
      const popupOverlay = document.getElementById('popupOverlay');

      popupTitle.textContent = `${authorData.name} - Publications`;

      if (!authorData.all_publications || !Array.isArray(authorData.all_publications)) {
        popupBody.innerHTML = `
          <div style="color: #666; font-size: 11px;">
            <strong>Author:</strong> ${authorData.name}<br>
            <strong>Department:</strong> ${authorData.department || 'Unknown'}<br>
            <strong>Papers in this theme:</strong> ${authorData.dominant_papers || 0}<br>
            <strong>Total papers:</strong> ${authorData.value || 0}<br><br>
            <div style="color: #ff6b35;">Publication details are not available. Please regenerate the data.</div>
          </div>`;
        popupOverlay.style.display = 'block';
        return;
      }

      let clusterThemeMap = {};
      if (rawData && rawData.complete_cluster_theme_mapping) {
        clusterThemeMap = rawData.complete_cluster_theme_mapping;
      } else if (rawData && rawData.children) {
        rawData.children.forEach(cluster => {
          (cluster.children || []).forEach(theme => {
            const mapping = {
              cluster_id: cluster.id,
              cluster_name: cluster.name.replace(/^\d+:\s*/, ''),
              theme_id: theme.id,
              theme_name: (theme.name || '').replace(/^Theme \d+:\s*/, '')
            };
            clusterThemeMap[`${parseInt(cluster.id)}_${parseInt(theme.id)}`] = mapping;
          });
        });
      }

      const pubsByYear = {};
      authorData.all_publications.forEach(pub => {
        const year = pub.year || 'Unknown';
        if (!pubsByYear[year]) pubsByYear[year] = [];
        pubsByYear[year].push(pub);
      });

      const sortedYears = Object.keys(pubsByYear).sort((a, b) => {
        if (a === 'Unknown') return 1;
        if (b === 'Unknown') return -1;
        return parseInt(b) - parseInt(a);
      });

      let html = `<div style="margin-bottom: 8px; color: #666; font-size: 10px;">
        <strong>Total:</strong> ${authorData.all_publications.length} |
        <strong>This theme:</strong> ${authorData.theme_publications ? authorData.theme_publications.length : 0} |
        <strong>Dept:</strong> ${authorData.department || ''}
      </div>`;

      sortedYears.forEach(year => {
        html += `<div style="margin-bottom: 12px;">
          <h4 class="publication-year">${year} (${pubsByYear[year].length})</h4>`;

        pubsByYear[year].forEach(pub => {
          const isInThisTheme = authorData.theme_publications &&
                                authorData.theme_publications.some(tp => tp.scopus_id === pub.scopus_id);
          const highlight = isInThisTheme ? 'border-left-color: #ff6b35; background: #fff3f0;' : '';

          let clusterThemeInfo = clusterThemeMap[`${parseInt(pub.cluster_id)}_${parseInt(pub.theme_id)}`];

          html += `<div class="publication-item" style="${highlight}">
            <div class="publication-title">${pub.title}</div>
            <div class="publication-meta">
              ID: ${pub.scopus_id}
              ${isInThisTheme ? ' <span style="color: #ff6b35; font-weight: bold;">(Current)</span>' : ''}
            </div>`;

            if (clusterThemeInfo) {
              html += `<div class="cluster-theme-info">ðŸ“‚ ${clusterThemeInfo.cluster_name} â†’ ${clusterThemeInfo.theme_name}</div>`;
            } else {
              html += `<div class="cluster-theme-info" style="color: #999;">ðŸ“‚ Cluster ${pub.cluster_id} â†’ Theme ${pub.theme_id} (not found)</div>`;
            }

          html += `</div>`;
        });
        html += '</div>';
      });

      popupBody.innerHTML = html;
      popupOverlay.style.display = 'block';
    }

    function showClusterThemePublications(data, type) {
      const popupTitle = document.getElementById('popupTitle');
      const popupBody = document.getElementById('popupBody');
      const popupOverlay = document.getElementById('popupOverlay');

      const count = data.publication_count || 0;
      const publications = data.all_publications || [];
      
      popupTitle.textContent = `${type === 'cluster' ? 'Cluster' : 'Theme'}: ${data.name} - ${count} Publications`;

      if (publications.length === 0) {
        popupBody.innerHTML = `
          <div style="color: #666; font-size: 11px;">
            <strong>${type === 'cluster' ? 'Cluster' : 'Theme'}:</strong> ${data.name}<br>
            <strong>Total publications:</strong> ${count}<br><br>
            <div style="color: #ff6b35;">No publication details available.</div>
          </div>`;
        popupOverlay.style.display = 'block';
        return;
      }

      const pubsByYear = {};
      publications.forEach(pub => {
        const year = pub.year || 'Unknown';
        if (!pubsByYear[year]) pubsByYear[year] = [];
        pubsByYear[year].push(pub);
      });

      const sortedYears = Object.keys(pubsByYear).sort((a, b) => {
        if (a === 'Unknown') return 1;
        if (b === 'Unknown') return -1;
        return parseInt(b) - parseInt(a);
      });

	let html = `<div class="sticky-close"><button type="button" onclick="closePopup()">Close Ã—</button></div>`;
	html += `<div style="margin-bottom: 8px; color: #666; font-size: 10px;">
	  <strong>${type === 'cluster' ? 'Cluster' : 'Theme'}:</strong> ${data.name}<br>
	  <strong>Total publications:</strong> ${publications.length}
	</div>`;


      sortedYears.forEach(year => {
        html += `<div style="margin-bottom: 12px;">
          <h4 class="publication-year">${year} (${pubsByYear[year].length})</h4>`;

        pubsByYear[year].forEach(pub => {
          html += `<div class="publication-item">
            <div class="publication-title">${pub.title || 'Untitled'}</div>
            <div class="publication-meta">ID: ${pub.scopus_id}</div>
            <div class="cluster-theme-info">ðŸ“‚ Cluster ${pub.cluster_id} â†’ Theme ${pub.theme_id}</div>
          </div>`;
        });
        html += '</div>';
      });

      popupBody.innerHTML = html;
      popupOverlay.style.display = 'block';
    }

    function closePopup() { document.getElementById('popupOverlay').style.display = 'none'; }
    document.getElementById('popupOverlay').addEventListener('click', function(e) { if (e.target === this) closePopup(); });

    function openCollabPage(authorData){
      const aid = authorData.author_id || (String(authorData.id||'').match(/author_(\d+)_/)||[])[1];
      const total = authorData.value || (authorData.all_publications ? authorData.all_publications.length : '');
      const name = encodeURIComponent(authorData.name || '');
      const url = `authorships.html?aid=${encodeURIComponent(aid)}&name=${name}&total=${encodeURIComponent(total)}`;
      window.location.href = url;
    }

    function openAuthorshipsPage(authorData){
      const aid = authorData.author_id || (String(authorData.id||'').match(/author_(\d+)_/)||[])[1];
      const total = authorData.value || (authorData.all_publications ? authorData.all_publications.length : '');
      const name = encodeURIComponent(authorData.name || '');
      const url = `collab.html?aid=${encodeURIComponent(aid)}&name=${name}&total=${encodeURIComponent(total)}`;
      window.location.href = url;
    }

    const timestamp = Date.now();
    fetch(`./clusters.json?v=${timestamp}`)
      .then(r => r.json())
      .then(data => { rawData = data; updateVisualization(); })
      .catch(err => {
        document.getElementById("mount").innerHTML = `
          <div style="padding: 20px; text-align: center;">
            <h3>Error loading data</h3>
            <p>Make sure clusters.json is available and valid.</p>
            <p>Error: ${err.message}</p>
            <button onclick="location.reload()">Reload Page</button>
          </div>`;
      });

    function updateVisualization() {
      const layoutSelect = document.getElementById('layoutSelect');
      const minPapersInput = document.getElementById('minPapers');

      currentLayout = layoutSelect.value;
      minPapers = parseInt(minPapersInput.value) || 1;

      document.getElementById("mount").innerHTML = "";

      if (currentLayout === 'tree') renderTreeVisualization();
      else renderClusterVisualization();
    }

    function filterDataByMinPapers(data) {
      const filtered = JSON.parse(JSON.stringify(data));
      filtered.children = (filtered.children || []).map(cluster => {
        cluster.children = (cluster.children || []).map(theme => {
          theme.children = (theme.children || []).filter(author => {
            const v = author.dominant_papers || 0;
            return v >= minPapers;
          });
          return theme;
        }).filter(theme => theme.children.length > 0);
        return cluster;
      }).filter(cluster => cluster.children.length > 0);
      return filtered;
    }

    /* dynamic metrics for visible authors: unique pubs and visible authors */
    function computeDynamicMetricsForCluster(cluster){
      const themes = new Map();
      const clusterPubSet = new Set();
      const clusterAuthorSet = new Set();

      (cluster.children || []).forEach(theme => {
        const themePubSet = new Set();
        const themeAuthors = theme.children || [];

        themeAuthors.forEach(author => {
          const aid = author.author_id || author.id;
          if (aid != null) clusterAuthorSet.add(String(aid));

          const pubs = Array.isArray(author.theme_publications)
            ? author.theme_publications
            : (author.all_publications || []);

          pubs.forEach(p => {
            if (!p) return;
            const inThis = Number(p.cluster_id) === Number(cluster.id) &&
                           Number(p.theme_id) === Number(theme.id);
            if (inThis && p.scopus_id != null) themePubSet.add(String(p.scopus_id));
          });
        });

        themePubSet.forEach(id => clusterPubSet.add(id));
        themes.set(theme.id, { pubs: themePubSet.size, authors: themeAuthors.length });
      });

      return { cluster: { pubs: clusterPubSet.size, authors: clusterAuthorSet.size }, themes };
    }

    function authorSet(author, scope){
      const aid = author.author_id || author.id;
      let pubs = Array.isArray(author.theme_publications)
        ? author.theme_publications
        : (author.all_publications || []);
      const set = new Set();
      const arr = [];
      pubs.forEach(p => {
        if (!p || p.scopus_id == null) return;
        if (scope.filter(p)) {
          const sid = String(p.scopus_id);
          if (!set.has(sid)) { set.add(sid); arr.push(p); }
        }
      });
      return { aid: String(aid ?? Math.random()), name: author.name || 'Unknown', set, pubs: arr };
    }

    function computeOverlapForTheme(theme, clusterId){
      const pubInfo = new Map();
      const authors = (theme.children || []).map(a => authorSet(a, {
        filter: (p) => Number(p.cluster_id) === Number(clusterId) && Number(p.theme_id) === Number(theme.id)
      }));
      authors.forEach(a => a.pubs.forEach(p => {
        const sid = String(p.scopus_id);
        if (!pubInfo.has(sid)) pubInfo.set(sid, { title: p.title || '', year: p.year || '' });
      }));
      return { authors, pubInfo };
    }

    function computeOverlapForCluster(cluster){
      const tmp = new Map();
      const pubInfo = new Map();
      (cluster.children || []).forEach(theme => {
        (theme.children || []).forEach(author => {
          const rec = authorSet(author, { filter: (p) => Number(p.cluster_id) === Number(cluster.id) });
          if (!tmp.has(rec.aid)) tmp.set(rec.aid, { aid: rec.aid, name: rec.name, set: new Set(), pubs: [] });
          const dest = tmp.get(rec.aid);
          rec.pubs.forEach(p => {
            const sid = String(p.scopus_id);
            if (!dest.set.has(sid)) { dest.set.add(sid); dest.pubs.push(p); }
            if (!pubInfo.has(sid)) pubInfo.set(sid, { title: p.title || '', year: p.year || '' });
          });
        });
      });
      return { authors: Array.from(tmp.values()), pubInfo };
    }

    function makeMatrix(authors){
      const n = authors.length;
      const counts = Array.from({length:n}, () => Array(n).fill(0));
      const ids = Array.from({length:n}, () => Array(n).fill(null));
      for (let i=0;i<n;i++){
        for (let j=0;j<n;j++){
          if (i===j){
            counts[i][j] = authors[i].set.size;
            ids[i][j] = Array.from(authors[i].set);
          } else {
            const inter = [];
            authors[i].set.forEach(sid => { if (authors[j].set.has(sid)) inter.push(sid); });
            counts[i][j] = inter.length;
            ids[i][j] = inter;
          }
        }
      }
      return { counts, ids };
    }

    function colorForCount(c, maxC){
      if (!maxC || c <= 0) return '#ffffff';        // zero stays white
      const t = c / maxC;                            // 0..1
      const alpha = 0.15 + 0.75 * t;                 // 0.15..0.90
      return `rgba(2,132,199, ${alpha.toFixed(3)})`; // blue with variable alpha
    }

    function showOverlapMatrix(nodeData, nodeType, clusterCtx){
      const popupTitle = document.getElementById('popupTitle');
      const popupBody  = document.getElementById('popupBody');
      const popupOverlay = document.getElementById('popupOverlay');

      const payload = nodeType === 'theme'
        ? computeOverlapForTheme(nodeData, clusterCtx.id)
        : computeOverlapForCluster(nodeData);

      const authors = payload.authors.slice().sort((a,b)=>a.name.localeCompare(b.name));
      const { counts, ids } = makeMatrix(authors);

      const titleText = nodeType === 'theme'
        ? `Shared publications â€” Theme ${(nodeData.name||'').replace(/^Theme \d+:\s*/,'')}`
        : `Shared publications â€” Cluster ${nodeData.name}`;
      popupTitle.textContent = titleText;

	let html = '';
	html += `<div class="sticky-close"><button type="button" onclick="closePopup()">Close Ã—</button></div>`;
	html += `<div class="matrix-caption">Authors shown ${authors.length}. Click a cell to list shared publications.</div>`;
	html += '<div style="overflow:auto; max-height:70vh;">';
	html += '<table class="matrix"><thead><tr><th></th>';
	authors.forEach(a => { html += `<th title="${a.name}">${a.name}</th>`; });
	html += '</tr></thead><tbody>';

	for (let i=0;i<authors.length;i++){
	  html += `<tr><th title="${authors[i].name}">${authors[i].name}</th>`;
	  for (let j=0;j<authors.length;j++){
		const c = counts[i][j];
		const cls = (i===j) ? 'self' : (c===0 ? 'zero' : '');
		html += `<td class="${cls}" data-i="${i}" data-j="${j}" style="cursor:pointer">${c}</td>`;
	  }
	  html += '</tr>';
	}
	html += '</tbody></table></div>';
	html += '<div id="matrixDetails" style="margin-top:10px; font-size:12px;"></div>';

	popupBody.innerHTML = html;


      // gradient coloring
      let maxC = 0;
      counts.forEach(row => row.forEach(v => { if (v > maxC) maxC = v; }));
      popupBody.querySelectorAll('td[data-i]').forEach(td => {
        const i = Number(td.getAttribute('data-i'));
        const j = Number(td.getAttribute('data-j'));
        const c = counts[i][j];
        td.style.background = colorForCount(c, maxC);
      });

      // click to list shared
      popupBody.querySelectorAll('td[data-i]').forEach(td => {
        td.addEventListener('click', () => {
          const i = Number(td.getAttribute('data-i'));
          const j = Number(td.getAttribute('data-j'));
          const list = ids[i][j] || [];
          const detailsDiv = document.getElementById('matrixDetails');

          if (list.length === 0){
            detailsDiv.innerHTML = '<div class="matrix-caption">No shared publications.</div>';
            return;
          }

          let out = `<div class="matrix-caption">Shared publications between <strong>${authors[i].name}</strong> and <strong>${authors[j].name}</strong> (${list.length})</div>`;
          out += '<ul style="margin:6px 0 0 16px; padding:0;">';
          list.forEach(sid => {
            const info = payload.pubInfo.get(String(sid)) || {};
            out += `<li style="margin:2px 0;">${sid} â€” ${info.title || ''} ${info.year ? '('+info.year+')' : ''}</li>`;
          });
          out += '</ul>';
          detailsDiv.innerHTML = out;
        });
      });

      popupOverlay.style.display = 'block';
    }

    function renderTreeVisualization() {
      const filteredData = filterDataByMinPapers(rawData);
      const clusters = filteredData.children || [];
      const palette = d3.schemeTableau10.concat(d3.schemeSet3 || []);
      const color = d3.scaleOrdinal(clusters.map(d => d.id), palette.slice(0, clusters.length));
	  const TREE_BOTTOM_PAD = 60;   // extra pixels at bottom of each cluster SVG

      const containerDiv = document.createElement("div");
      containerDiv.style.display = "flex";
      containerDiv.style.flexDirection = "column";
      containerDiv.style.gap = "20px";
      containerDiv.style.padding = "20px";

      clusters.forEach((cluster) => {
        const clusterTreeData = {
          name: cluster.name, type: 'cluster', id: cluster.id, cluster_id: cluster.id,
          children: cluster.children || [], publication_count: cluster.publication_count,
          all_publications: cluster.all_publications
        };

        const root = d3.hierarchy(clusterTreeData);

        root.sort((a, b) => {
          const typeOrder = { 'cluster': 1, 'theme': 2, 'author': 3 };
          const aType = typeOrder[a.data.type] || 4;
          const bType = typeOrder[b.data.type] || 4;
          if (aType !== bType) return d3.ascending(aType, bType);

          if (a.data.type === 'author' && b.data.type === 'author') {
            const aCount = (a.data.dominant_papers != null)
              ? a.data.dominant_papers
              : ((a.data.theme_publications && a.data.theme_publications.length) || 0);
            const bCount = (b.data.dominant_papers != null)
              ? b.data.dominant_papers
              : ((b.data.theme_publications && b.data.theme_publications.length) || 0);
            const byCount = d3.descending(aCount, bCount);
            return byCount !== 0 ? byCount : d3.ascending((a.data.name || ''), (b.data.name || ''));
          }
          return d3.ascending((a.data.name || ''), (b.data.name || ''));
        });

        const treeWidth = 2200;
        const dx = 20;
        const tree = d3.tree().nodeSize([dx, treeWidth / (root.height + 1)]);
        tree(root);

        let x0 = Infinity, x1 = -x0;
        root.each(d => { if (d.x > x1) x1 = d.x; if (d.x < x0) x0 = d.x; });
        const height = x1 - x0 + dx * 2 + TREE_BOTTOM_PAD;

        const svg = d3.create("svg")
          .attr("width", treeWidth)
          .attr("height", height)
          .attr("viewBox", [-80, x0 - dx, treeWidth, height])
          .attr("style", "max-width: 100%; height: auto; font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;");

        svg.append("g")
          .attr("fill", "none")
          .attr("stroke-opacity", 0.5)
          .attr("stroke-width", 2)
          .selectAll("path")
          .data(root.links())
          .join("path")
          .attr("stroke", color(cluster.id))
          .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

        const node = svg.append("g")
          .attr("stroke-linejoin", "round")
          .attr("stroke-width", 4)
          .selectAll("g")
          .data(root.descendants())
          .join("g")
          .attr("transform", d => `translate(${d.y},${d.x})`)
          .style("cursor", d => d.data.type === 'author' ? 'pointer' : 'default')
          .on("click", function (event, d) {
            if (d.data.type === 'author') {
              event.stopPropagation();
              showAuthorPublications(d.data);
            }
          });

        node.append("circle")
          .attr("r", d => d.data.type === 'cluster' ? 8 : (d.data.type === 'theme' ? 5 : 3))
          .attr("fill", d => {
            if (d.data.type === 'cluster') return color(cluster.id);
            if (d.data.type === 'theme') return d3.color(color(cluster.id)).darker(0.5);
            return d3.color(color(cluster.id)).darker(1);
          })
          .attr("stroke", "white");

        const labels = node.append("text")
          .attr("dy", "0.31em")
          .attr("x", d => (d.data.type === 'cluster' ? 15 : (d.data.type === 'theme' ? 12 : 20)))
          .attr("text-anchor", "start")
          .attr("stroke", "white")
          .attr("stroke-width", d => d.data.type === 'author' ? 3 : 4)
          .attr("paint-order", "stroke")
          .style("font-weight", d => (d.data.type === 'cluster' ? 700 : (d.data.type === 'theme' ? 600 : 400)))
          .style("font-size", d => (d.data.type === 'cluster' ? "24px" : (d.data.type === 'theme' ? "20px" : "18px")))
          .style("fill", "black")
          .text(d => {
            if (d.data.type === 'cluster') return d.data.name;
            if (d.data.type === 'theme') return (d.data.name || '').replace(/^Theme \d+: /, '');
            return d.data.name;
          })
          .each(function (d) {
            const text = d3.select(this);
            const maxLength = d.data.type === 'cluster' ? 70 : (d.data.type === 'theme' ? 50 : 40);
            const currentText = text.text();
            if (currentText.length > maxLength) text.text(currentText.substring(0, maxLength) + "...");
          });
		
		setTimeout(() => {
  const dyn = computeDynamicMetricsForCluster(cluster);

  node.filter(d => d.data.type === 'cluster' || d.data.type === 'theme')
    .each(function(d) {
      const nodeGroup = d3.select(this);
      const publicationCount = d.data.publication_count || 0;

      // left align with the name
      const baseX = d.data.type === 'cluster' ? 15 : 12;

      // measure name height and add gap
      const labelEl = nodeGroup.select('text').node();
      const labelH  = labelEl ? labelEl.getBBox().height : (d.data.type === 'cluster' ? 24 : 18);
      const gap = d.data.type === 'cluster'
        ? (typeof METRIC_GAP_CLUSTER !== 'undefined' ? METRIC_GAP_CLUSTER : 8)
        : (typeof METRIC_GAP_THEME   !== 'undefined' ? METRIC_GAP_THEME   : 0);
      const baseY = labelH + gap;

      // row under the name
      const row = nodeGroup.append("g")
        .attr("transform", `translate(${baseX}, ${baseY})`);

      let xPos = 0;

      // red total (clickable)
      if (publicationCount > 0) {
        const red = row.append("text")
          .text(`(${publicationCount})`)
          .attr("x", xPos)
          .attr("y", 0)
          .attr("dy", "0.31em")
          .attr("class", "pub-count")
		  .style("fill", "#dc2626")
          .style("cursor", "pointer")
          .on("click", function(ev) {
            ev.stopPropagation();
            showClusterThemePublications(d.data, d.data.type);
          })
          .on("mouseover", function() {
            d3.select(this).style("fill", "#b91c1c").style("text-decoration", "none");
          })
          .on("mouseout", function() {
            d3.select(this).style("fill", "#dc2626").style("text-decoration", "underline");
          });

        xPos += (red.node()?.getBBox()?.width || 0) + 8;
      }

      // gray [P:x]
      const dynPubs = d.data.type === 'cluster'
        ? dyn.cluster.pubs
        : (dyn.themes.get(d.data.id)?.pubs || 0);

      const gray = row.append("text")
        .text(`[P:${dynPubs}]`)
        .attr("x", xPos)
        .attr("y", 0)
        .attr("dy", "0.31em")
        .attr("class", "dyn-pubs");

      xPos += (gray.node()?.getBBox()?.width || 0) + 8;

      // blue {A:y}
      const dynAuths = d.data.type === 'cluster'
        ? dyn.cluster.authors
        : (dyn.themes.get(d.data.id)?.authors || 0);

      const blue = row.append("text")
        .text(`{A:${dynAuths}}`)
        .attr("x", xPos)
        .attr("y", 0)
        .attr("dy", "0.31em")
        .attr("class", "dyn-auths");

      xPos += (blue.node()?.getBBox()?.width || 0) + 10;

      // [matrix] link
      row.append("text")
        .text("[matrix]")
        .attr("x", xPos)
        .attr("y", 0)
        .attr("dy", "0.31em")
        .style("font-size", d.data.type === 'cluster' ? "14px" : "13px")
        .style("fill", "#0ea5e9")
        .style("cursor", "pointer")
        .on("click", function(ev){
          ev.stopPropagation();
          if (d.data.type === 'theme') {
            showOverlapMatrix(d.data, 'theme', cluster);
          } else {
            showOverlapMatrix(d.data, 'cluster');
          }
        });
    });
}, 100);



        const iconLayer = svg.append("g");
        root.descendants()
          .filter(d => d.data.type === 'author')
          .forEach(d => {
            const yFixed = treeWidth - 60;
            const xAligned = d.x;

            const iconGroup = iconLayer.append('g')
              .attr('transform', `translate(${yFixed},${xAligned})`)
              .style('cursor', 'pointer')
              .on('click', (ev) => {
                ev.stopPropagation();
                openCollabPage(d.data);
              });

            const blue = '#007acc';
            iconGroup.append('circle').attr('cx', 4).attr('cy', 0).attr('r', 6).attr('fill', blue);
            iconGroup.append('circle').attr('cx', 12).attr('cy', 0).attr('r', 6).attr('fill', blue);
            iconGroup.append('path').attr('d', 'M-2,6 C3,2 13,2 18,6 L18,9 L-2,9 Z').attr('fill', blue);
          });

        node.filter(d => d.data.type === 'author')
          .each(function(d) {
            const nodeGroup = d3.select(this);
            const authorName = d.data.name || '';
            const truncatedName = authorName.length > 40 ? authorName.substring(0, 40) + "..." : authorName;
            const estimatedWidth = truncatedName.length * 9;
            const collabX = 20 + estimatedWidth + LINK_PAD;

            const collabText = nodeGroup.append("text")
              .text("[collab]")
              .attr("x", collabX)
              .attr("y", 0)
              .attr("dy", "0.31em")
              .style("font-size", "12px")
              .style("fill", "#007acc")
              .style("cursor", "pointer")
              .on("click", function (ev) {
                ev.stopPropagation();
                openCollabPage(d.data);
              });

            const collabW = collabText.node()?.getComputedTextLength?.() || 54;
            const x2 = collabX + collabW + LINK_GAP;

            nodeGroup.append("text")
              .text("[authorships]")
              .attr("x", x2)
              .attr("y", 0)
              .attr("dy", "0.31em")
              .style("font-size", "12px")
              .style("fill", "#16a34a")
              .style("cursor", "pointer")
              .on("click", function (ev) {
                ev.stopPropagation();
                openAuthorshipsPage(d.data);
              });
          });

        containerDiv.appendChild(svg.node());
      });

      document.getElementById("mount").appendChild(containerDiv);
    }

    function renderClusterVisualization() {
      document.getElementById("mount").innerHTML =
        '<div style="padding:20px;color:#6b7280;">Cluster layout not implemented in this file.</div>';
    }

    document.getElementById('layoutSelect').addEventListener('change', updateVisualization);
    document.getElementById('minPapers').addEventListener('change', updateVisualization);
  </script>
</body>
</html>
